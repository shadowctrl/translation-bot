name: Build and Deploy

on:
  push:
    branches:
      - prod
  workflow_dispatch

env:
  NAMESPACE: murali
  REGISTRY_HOST: 192.168.0.103
  IMAGE_NAME: translation-bot

jobs:
  prepare-env:
    name: Prepare Environment
    runs-on: ubuntu-latest
    outputs:
      env-created: ${{ steps.create-env.outputs.success}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create .env file
        id: create-env
        run: |
          echo "Creating Environment from Git secrets"
          cat > .env << EOF
          BOT_TOKEN=${{secrets.BOT_TOKEN}}
          MONGO_URI=${{secrets.MONGO_URI}}
          OPENAI_BASE_URL=${{secrets.OPENAI_BASE_URL}}
          OPENAI_MODEL=${{secrets.OPENAI_MODEL}}
          OPENAI_API_KEY=${{secrets.OPENAI_API_KEY}}
          EOF 

          echo "Env file creation successful"
          echo "success=true" >> $GITHUB_OUTPUT
      
      - name: Upload .env as artifact
        uses: actions/upload-artifact@v4
        with:
          name: env-file
          path: .env
          retention-days: 1

  build-and-push:
    name: Docker build
    runs-on: ubuntu-latest
    needs: prepare-env
    if: needs.prepare-env.outputs.env-created == 'true'
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download .env file
        uses: actions/download-artifact@v4
        with:
          name: env-file
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        run: | 
          IMAGE_TAG="${GITHUB_SHA:0:8}-$(date +%s)"
          FULL_IMAGE="${REGISTRY_HOST}/${IMAGE_NAME}:${IMAGE_TAG}"
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "full-image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
          echo "FULL_IMAGE=${FULL_IMAGE}" >> $GITHUB_ENV
        
      - name: Build docker image
        run: |
          docker buildx create --use --name arm-builder
          docker buildx build \
          --platform linux/arm64 \
          --tag ${{ env.FULL_IMAGE }} \
          --tag ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:latest \
          --load \
          .

      - name: Save image
        run: |
          docker save ${{ env.FULL_IMAGE }} > translation-bot-image.tar
          ls -lh translation-bot-image.tar
      
      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: translation-bot-image.tar
          retention-days: 1
      
  setup-requirements:
    name: Setup Requirements
    runs-on: ubuntu-latest
    needs: [prepare-env, build-and-push]
    outputs:
      deployment-ready: ${{ steps.push-image.outputs.success }}    
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          
      - name: Copy image to server and push to docker registry
        id: push-image
        run: |
          echo "Copying Docker image to server..."
          scp -i ~/.ssh/id_rsa translation-bot-image.tar ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:/tmp/
          
          echo "Loading and pushing image to private registry..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Load the image
            docker load < /tmp/translation-bot-image.tar
            
            # Tag for private registry
            IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
            docker tag ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} ${{ env.REGISTRY_HOST }}:5000/${{ env.IMAGE_NAME }}:${IMAGE_TAG}
            docker tag ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} ${{ env.REGISTRY_HOST }}:5000/${{ env.IMAGE_NAME }}:latest
            
            # Push to private registry
            docker push ${{ env.REGISTRY_HOST }}:5000/${{ env.IMAGE_NAME }}:${IMAGE_TAG}
            docker push ${{ env.REGISTRY_HOST }}:5000/${{ env.IMAGE_NAME }}:latest
            
            # Clean up
            rm /tmp/translation-bot-image.tar
            
            echo "Image pushed successfully to private registry"
          EOF
          
          echo "success=true" >> $GITHUB_OUTPUT

  prepare-provisioning:
    name: Prepare Provisioning
    runs-on: ubuntu-latest
    needs: [build-and-push, setup-requirements]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Process K3s manifests with secrets substitution
        run: |
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
          mkdir -p processed-k3s          
          for file in k3s/*.yaml k3s/*.yml; do
            if [[ -f "$file" ]]; then
              filename=$(basename "$file")
              echo "Processing $filename..."
              
              # Substitute environment variables and secrets in the YAML files
              envsubst << EOF > "processed-k3s/$filename"
          $(cat "$file" | \
            sed "s|\${NAMESPACE}|${{ env.NAMESPACE }}|g" | \
            sed "s|\${REGISTRY_HOST}|${{ env.REGISTRY_HOST }}|g" | \
            sed "s|\${IMAGE_NAME}|${{ env.IMAGE_NAME }}|g" | \
            sed "s|\${IMAGE_TAG}|${IMAGE_TAG}|g" | \
            sed "s|\${BOT_TOKEN_B64}|$(echo -n '${{ secrets.BOT_TOKEN }}' | base64 -w 0)|g" | \
            sed "s|\${MONGO_URI_B64}|$(echo -n '${{ secrets.MONGO_URI }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_BASE_URL_B64}|$(echo -n '${{ secrets.OPENAI_BASE_URL }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_MODEL_B64}|$(echo -n '${{ secrets.OPENAI_MODEL }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_API_KEY_B64}|$(echo -n '${{ secrets.OPENAI_API_KEY }}' | base64 -w 0)|g")
          EOF
              
              echo "‚úÖ Processed $filename"
            fi
          done
          
          # List processed files
          echo "Processed K3s manifests:"
          ls -la processed-k3s/

      - name: Upload processed K3s manifests as artifact
        uses: actions/upload-artifact@v4
        with:
          name: k3s-manifests
          path: processed-k3s/
          retention-days: 7

  provisioning-deployment:
    name: Provisioning Deployment
    runs-on: ubuntu-latest
    needs: [setup-requirements, prepare-provisioning]
    if: needs.setup-requirements.outputs.deployment-ready == 'true'
    outputs:
      provisioning-status: ${{ steps.apply-k3s.outputs.status }}
    steps:
      - name: Download K3s manifests
        uses: actions/download-artifact@v4
        with:
          name: k3s-manifests
          path: k3s/

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Copy K3s manifests to server
        run: |
          echo "üìÇ Copying processed K3s manifests to server..."
          scp -i ~/.ssh/id_rsa -r k3s/ ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:/tmp/k3s-deployment/

      - name: Apply K3s deployment
        id: apply-k3s
        run: |
          echo "üöÄ Applying K3s deployment from existing manifests..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /tmp/k3s-deployment
            
            # Apply namespace first (if exists) - K3s will skip if already exists
            if [ -f "namespace.yaml" ] || [ -f "namespace.yml" ]; then
              echo "üìã Applying namespace..."
              kubectl apply -f namespace.yaml 2>/dev/null || kubectl apply -f namespace.yml 2>/dev/null || echo "Namespace already exists or not found"
            fi
            
            # Apply all other manifests in alphabetical order
            echo "‚öôÔ∏è Applying all K3s manifests..."
            for file in *.yaml *.yml; do
              if [[ -f "$file" && "$file" != "namespace.yaml" && "$file" != "namespace.yml" ]]; then
                echo "Applying $file..."
                kubectl apply -f "$file"
              fi
            done
            
            # Wait for deployment to be ready (if deployment exists)
            if kubectl get deployment translation-bot -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
              echo "‚è≥ Waiting for deployment to be ready..."
              kubectl rollout status deployment/translation-bot -n ${{ env.NAMESPACE }} --timeout=300s
            fi
            
            echo "‚úÖ All K3s manifests applied successfully!"
          EOF
          
          echo "status=success" >> $GITHUB_OUTPUT

  deployment-provisioned:
    name: Deployment Provisioned
    runs-on: ubuntu-latest
    needs: [provisioning-deployment]
    if: needs.provisioning-deployment.outputs.provisioning-status == 'success'
    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Verify deployment and get status
        run: |
          echo "üîç Verifying deployment status..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            echo "==================== DEPLOYMENT STATUS ===================="
            
            # Get namespace status
            echo "üì¶ Namespace:"
            kubectl get namespace ${{ env.NAMESPACE }} -o wide
            
            echo ""
            echo "üöÄ Deployment Status:"
            kubectl get deployment translation-bot -n ${{ env.NAMESPACE }} -o wide
            
            echo ""
            echo "üèÉ Pod Status:"
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            
            echo ""
            echo "üîê Secrets:"
            kubectl get secrets -n ${{ env.NAMESPACE }}
            
            echo ""
            echo "üåê Services:"
            kubectl get services -n ${{ env.NAMESPACE }} -o wide
            
            echo ""
            echo "üìã ConfigMaps:"
            kubectl get configmaps -n ${{ env.NAMESPACE }}
            
            echo ""
            echo "üìä Recent Events:"
            kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
            
            echo ""
            echo "üìù Application Logs (Last 20 lines):"
            kubectl logs -n ${{ env.NAMESPACE }} -l app=translation-bot --tail=20 || echo "No logs available yet"
            
            echo ""
            echo "==================== DEPLOYMENT COMPLETE ===================="
          EOF

      - name: Cleanup temporary files
        run: |
          echo "üßπ Cleaning up temporary files on server..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Clean up temporary deployment files
            rm -rf /tmp/k3s-deployment/
            
            # Clean up old Docker images (keep last 3)
            docker image prune -f
            
            echo "‚úÖ Cleanup completed"
          EOF

      - name: Send deployment notification
        run: |
          echo "üéâ Translation Bot Deployment Completed Successfully!"
          echo "üìã Deployment Summary:"
          echo "  - Image Tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "  - Namespace: ${{ env.NAMESPACE }}"
          echo "  - Registry: ${{ env.REGISTRY_HOST }}:5000"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Triggered by: ${{ github.actor }}"
          echo "  - Workflow: ${{ github.run_number }}"
          
          # You can add webhook notifications here if needed
          # curl -X POST -H 'Content-type: application/json' \
          # --data '{"text":"Translation Bot deployed successfully!"}' \
          # ${{ secrets.SLACK_WEBHOOK_URL }}