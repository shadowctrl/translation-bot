name: Build and Deploy

on:
  push:
    branches:
      - prod
  workflow_dispatch:

env:
  NAMESPACE: murali
  REGISTRY_HOST: 192.168.0.103:5000
  IMAGE_NAME: translation-bot

jobs:
  prepare-env:
    name: Prepare Environment
    runs-on: ubuntu-latest
    outputs:
      env-created: ${{ steps.create-env.outputs.success}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env file
        id: create-env
        run: |
          cat > .env << 'EOF'
          BOT_TOKEN=${{secrets.BOT_TOKEN}}
          MONGO_URI=${{secrets.MONGO_URI}}
          OPENAI_BASE_URL=${{secrets.OPENAI_BASE_URL}}
          OPENAI_MODEL=${{secrets.OPENAI_MODEL}}
          OPENAI_API_KEY=${{secrets.OPENAI_API_KEY}}
          EOF
              ls -l .env
              echo "success=true" >> $GITHUB_OUTPUT

      - name: Upload .env as artifact
        uses: actions/upload-artifact@v4
        with:
          name: env-file
          path: /home/runner/work/translation-bot/translation-bot/.env
          retention-days: 1
          include-hidden-files: true

  build-and-push:
    name: Docker build
    runs-on: ubuntu-latest
    needs: prepare-env
    if: needs.prepare-env.outputs.env-created == 'true'
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
      image-tar: ${{ steps.save-image.outputs.image-tar }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download .env file
        uses: actions/download-artifact@v4
        with:
          name: env-file

      - name: Set up QEMU for multi-platform builds
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:8}-$(date +%s)"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Build Docker image and save as TAR
        id: save-image
        run: |
          docker buildx create --use --name mybuilder || true
          docker buildx inspect mybuilder --bootstrap
          docker buildx build \
            --platform linux/arm64 \
            --output type=docker \
            -t ${IMAGE_NAME}:latest \
            -t ${IMAGE_NAME}:${{ env.IMAGE_TAG }} \
            .
          docker save ${IMAGE_NAME}:latest -o ${IMAGE_NAME}-image.tar
          echo "image-tar=${IMAGE_NAME}-image.tar" >> $GITHUB_OUTPUT

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: ${{ steps.save-image.outputs.image-tar }}
          retention-days: 1

  provision-setup:
    name: Setup Provision
    runs-on: ubuntu-latest
    needs: [prepare-env, build-and-push]
    outputs:
      deployment-ready: ${{ steps.mark-success.outputs.success }}
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Copy image to server and push to registry
        id: push-image
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: '${{ needs.build-and-push.outputs.image-tar }}'
          target: '/tmp/'

      - name: Load and push image to private registry
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            sudo docker load -i /tmp/${{ needs.build-and-push.outputs.image-tar }}
            sudo docker tag ${{ env.IMAGE_NAME }}:latest ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:latest
            sudo docker push ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:latest
            rm -f /tmp/${{ needs.build-and-push.outputs.image-tar }}

      - name: Mark success
        id: mark-success
        run: echo "success=true" >> $GITHUB_OUTPUT

  prepare-provisioning:
    name: Prepare Provisioning
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Process K3s manifests with secrets substitution
        run: |
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
          mkdir -p processed-k3s          
          for file in k3s/*.yaml k3s/*.yml; do
            if [[ -f "$file" ]]; then
              filename=$(basename "$file")
              envsubst << EOF > "processed-k3s/$filename"
          $(cat "$file" | \
            sed "s|\${NAMESPACE}|${{ env.NAMESPACE }}|g" | \
            sed "s|\${REGISTRY_HOST}|${{ env.REGISTRY_HOST }}|g" | \
            sed "s|\${IMAGE_NAME}|${{ env.IMAGE_NAME }}|g" | \
            sed "s|\${IMAGE_TAG}|${IMAGE_TAG}|g" | \
            sed "s|\${BOT_TOKEN_B64}|$(echo -n '${{ secrets.BOT_TOKEN }}' | base64 -w 0)|g" | \
            sed "s|\${MONGO_URI_B64}|$(echo -n '${{ secrets.MONGO_URI }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_BASE_URL_B64}|$(echo -n '${{ secrets.OPENAI_BASE_URL }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_MODEL_B64}|$(echo -n '${{ secrets.OPENAI_MODEL }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_API_KEY_B64}|$(echo -n '${{ secrets.OPENAI_API_KEY }}' | base64 -w 0)|g")
          EOF
            fi
          done

      - name: Upload processed K3s manifests as artifact
        uses: actions/upload-artifact@v4
        with:
          name: k3s-manifests
          path: processed-k3s/
          retention-days: 1

  provisioning-deployment:
    name: Provisioning Deployment
    runs-on: ubuntu-latest
    needs: [provision-setup, prepare-provisioning]
    if: needs.provision-setup.outputs.deployment-ready == 'true'
    environment: prod
    timeout-minutes: 30
    outputs:
      provisioning-status: ${{ steps.apply-k3s.outputs.status }}
    steps:
      - name: Download K3s manifests
        uses: actions/download-artifact@v4
        with:
          name: k3s-manifests
          path: k3s/

      - name: Copy K3s manifests to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: 'k3s/*'
          target: '/tmp/k3s-deployment/'

      - name: Debug and Apply K3s deployment
        id: apply-k3s
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 30m
          command_timeout: 30m
          script: |
            echo "=== DEBUG: Finding YAML files ==="
            echo "Contents of /tmp:"
            ls -la /tmp/ | grep k3s

            echo "Contents of /tmp/k3s-deployment:"
            ls -la /tmp/k3s-deployment/ 2>/dev/null || echo "Directory does not exist"

            echo "Searching for YAML files recursively:"
            find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | head -20

            # Find the actual directory with YAML files
            YAML_DIR=""
            if [ -d "/tmp/k3s-deployment" ]; then
              if ls /tmp/k3s-deployment/*.yaml >/dev/null 2>&1 || ls /tmp/k3s-deployment/*.yml >/dev/null 2>&1; then
                YAML_DIR="/tmp/k3s-deployment"
              elif ls /tmp/k3s-deployment/*/*.yaml >/dev/null 2>&1 || ls /tmp/k3s-deployment/*/*.yml >/dev/null 2>&1; then
                YAML_DIR="/tmp/k3s-deployment/k3s"
              fi
            fi

            if [ -z "$YAML_DIR" ]; then
              echo "ERROR: Could not find YAML files"
              exit 1
            fi

            echo "=== Using YAML directory: $YAML_DIR ==="
            cd "$YAML_DIR"

            echo "Files in working directory:"
            ls -la

            # Apply namespace first
            NAMESPACE_APPLIED=false
            for ns_file in namespace.yaml namespace.yml; do
              if [ -f "$ns_file" ]; then
                echo "Applying $ns_file..."
                sudo kubectl apply -f "$ns_file"
                NAMESPACE_APPLIED=true
                break
              fi
            done

            if [ "$NAMESPACE_APPLIED" = false ]; then
              echo "No namespace file found, creating namespace directly..."
              sudo kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | sudo kubectl apply -f -
            fi

            echo "Waiting for namespace to be ready..."
            sudo kubectl wait --for=condition=active namespace/${{ env.NAMESPACE }} --timeout=60s

            # Apply all other YAML files
            echo "Applying remaining manifests..."
            APPLIED_COUNT=0
            for file in *.yaml *.yml; do
              if [[ -f "$file" && "$file" != "namespace.yaml" && "$file" != "namespace.yml" ]]; then
                echo "Applying $file..."
                sudo kubectl apply -f "$file"
                APPLIED_COUNT=$((APPLIED_COUNT + 1))
              fi
            done

            echo "Applied $APPLIED_COUNT manifest files"

            # Handle deployment
            if sudo kubectl get deployment translation-bot -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
              echo "Restarting existing deployment..."
              sudo kubectl rollout restart deployment/translation-bot -n ${{ env.NAMESPACE }}
              sudo kubectl rollout status deployment/translation-bot -n ${{ env.NAMESPACE }} --timeout=300s
            else
              echo "Waiting for new deployment to be ready..."
              sudo kubectl wait --for=condition=available deployment/translation-bot -n ${{ env.NAMESPACE }} --timeout=300s
            fi

            echo "status=success" >> $GITHUB_OUTPUT

  deployment-provisioned:
    name: Deployment Provisioned
    runs-on: ubuntu-latest
    needs: [provisioning-deployment, build-and-push]
    if: needs.provisioning-deployment.outputs.provisioning-status == 'success'
    steps:
      - name: Verify deployment status
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            sudo kubectl get namespace ${{ env.NAMESPACE }} -o wide
            sudo kubectl get deployment translation-bot -n ${{ env.NAMESPACE }} -o wide
            sudo kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            sudo kubectl get secrets -n ${{ env.NAMESPACE }}
            sudo kubectl get services -n ${{ env.NAMESPACE }} -o wide
            sudo kubectl get configmaps -n ${{ env.NAMESPACE }}
            sudo kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
            sudo kubectl logs -n ${{ env.NAMESPACE }} -l app=translation-bot --tail=20 || echo "No logs available"

      - name: Cleanup deployment artifacts
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            rm -rf /tmp/k3s-deployment/
            sudo docker image prune -f

      - name: Deployment summary
        run: |
          echo "Translation Bot Deployment Complete"
          echo "Image Tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "Namespace: ${{ env.NAMESPACE }}"
          echo "Registry: ${{ env.REGISTRY_HOST }}"
          echo "Commit: ${{ github.sha }}"
          echo "Workflow: ${{ github.run_number }}"
