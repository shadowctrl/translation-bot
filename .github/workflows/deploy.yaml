name: Build and Deploy

on:
  push:
    branches:
      - prod
  workflow_dispatch:

env:
  NAMESPACE: murali
  REGISTRY_HOST: 192.168.0.103:5000
  IMAGE_NAME: translation-bot

jobs:
  prepare-env:
    name: Prepare Environment
    runs-on: ubuntu-latest
    outputs:
      env-created: ${{ steps.create-env.outputs.success}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env file
        id: create-env
        run: |
          cat > .env << 'EOF'
          BOT_TOKEN=${{secrets.BOT_TOKEN}}
          MONGO_URI=${{secrets.MONGO_URI}}
          OPENAI_BASE_URL=${{secrets.OPENAI_BASE_URL}}
          OPENAI_MODEL=${{secrets.OPENAI_MODEL}}
          OPENAI_API_KEY=${{secrets.OPENAI_API_KEY}}
          EOF
          ls -l .env
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Upload .env as artifact
        uses: actions/upload-artifact@v4
        with:
          name: env-file
          path: .env
          retention-days: 1

  build-and-push:
    name: Docker build
    runs-on: ubuntu-latest
    needs: prepare-env
    if: needs.prepare-env.outputs.env-created == 'true'
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
      image-tar: ${{ steps.save-image.outputs.image-tar }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download .env file
        uses: actions/download-artifact@v4
        with:
          name: env-file

      - name: Set up QEMU for multi-platform builds
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:8}-$(date +%s)"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Build Docker image and save as TAR
        id: save-image
        run: |
          docker buildx create --use --name mybuilder || true
          docker buildx inspect mybuilder --bootstrap
          docker buildx build \
            --platform linux/arm64 \
            --output type=docker \
            -t ${IMAGE_NAME}:latest \
            -t ${IMAGE_NAME}:${{ env.IMAGE_TAG }} \
            .
          docker save ${IMAGE_NAME}:latest -o ${IMAGE_NAME}-image.tar
          echo "image-tar=${IMAGE_NAME}-image.tar" >> $GITHUB_OUTPUT

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: ${{ steps.save-image.outputs.image-tar }}
          retention-days: 1

  provision-setup:
    name: Setup Provision
    runs-on: ubuntu-latest
    needs: [prepare-env, build-and-push]
    outputs:
      deployment-ready: ${{ steps.push-image.outputs.success }}
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Copy image to server and push to registry
        id: push-image
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: '${{ needs.build-and-push.outputs.image-tar }}'
          target: '/tmp/'

      - name: Load and push image to private registry
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            sudo docker load -i /tmp/${{ needs.build-and-push.outputs.image-tar }}
            IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
            sudo docker tag ${{ env.IMAGE_NAME }}:latest ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}
            sudo docker tag ${{ env.IMAGE_NAME }}:latest ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:latest
            sudo docker push ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}
            sudo docker push ${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:latest
            rm -f /tmp/${{ needs.build-and-push.outputs.image-tar }}
            echo "success=true" >> $GITHUB_OUTPUT

  prepare-provisioning:
    name: Prepare Provisioning
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Process K3s manifests with secrets substitution
        run: |
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
          mkdir -p processed-k3s          
          for file in k3s/*.yaml k3s/*.yml; do
            if [[ -f "$file" ]]; then
              filename=$(basename "$file")
              envsubst << EOF > "processed-k3s/$filename"
          $(cat "$file" | \
            sed "s|\${NAMESPACE}|${{ env.NAMESPACE }}|g" | \
            sed "s|\${REGISTRY_HOST}|${{ env.REGISTRY_HOST }}|g" | \
            sed "s|\${IMAGE_NAME}|${{ env.IMAGE_NAME }}|g" | \
            sed "s|\${IMAGE_TAG}|${IMAGE_TAG}|g" | \
            sed "s|\${BOT_TOKEN_B64}|$(echo -n '${{ secrets.BOT_TOKEN }}' | base64 -w 0)|g" | \
            sed "s|\${MONGO_URI_B64}|$(echo -n '${{ secrets.MONGO_URI }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_BASE_URL_B64}|$(echo -n '${{ secrets.OPENAI_BASE_URL }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_MODEL_B64}|$(echo -n '${{ secrets.OPENAI_MODEL }}' | base64 -w 0)|g" | \
            sed "s|\${OPENAI_API_KEY_B64}|$(echo -n '${{ secrets.OPENAI_API_KEY }}' | base64 -w 0)|g")
          EOF
            fi
          done

      - name: Upload processed K3s manifests as artifact
        uses: actions/upload-artifact@v4
        with:
          name: k3s-manifests
          path: processed-k3s/
          retention-days: 1

  provisioning-deployment:
    name: Provisioning Deployment
    runs-on: ubuntu-latest
    needs: [provision-setup, prepare-provisioning]
    if: needs.provision-setup.outputs.deployment-ready == 'true'
    environment: prod
    timeout-minutes: 30
    outputs:
      provisioning-status: ${{ steps.apply-k3s.outputs.status }}
    steps:
      - name: Download K3s manifests
        uses: actions/download-artifact@v4
        with:
          name: k3s-manifests
          path: k3s/

      - name: Copy K3s manifests to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: 'k3s/'
          target: '/tmp/k3s-deployment/'

      - name: Apply K3s deployment
        id: apply-k3s
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 30m
          command_timeout: 30m
          script: |
            cd /tmp/k3s-deployment
            if [ -f "namespace.yaml" ] || [ -f "namespace.yml" ]; then
              sudo kubectl apply -f namespace.yaml 2>/dev/null || sudo kubectl apply -f namespace.yml 2>/dev/null || true
            fi
            sudo kubectl wait --for=condition=active namespace/${{ env.NAMESPACE }} --timeout=60s
            for file in *.yaml *.yml; do
              if [[ -f "$file" && "$file" != "namespace.yaml" && "$file" != "namespace.yml" ]]; then
                sudo kubectl apply -f "$file"
              fi
            done
            if sudo kubectl get deployment translation-bot -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
              sudo kubectl rollout restart deployment/translation-bot -n ${{ env.NAMESPACE }}
              sudo kubectl rollout status deployment/translation-bot -n ${{ env.NAMESPACE }} --timeout=300s
            fi
            echo "status=success" >> $GITHUB_OUTPUT

  deployment-provisioned:
    name: Deployment Provisioned
    runs-on: ubuntu-latest
    needs: [provisioning-deployment, build-and-push]
    if: needs.provisioning-deployment.outputs.provisioning-status == 'success'
    steps:
      - name: Verify deployment status
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            sudo kubectl get namespace ${{ env.NAMESPACE }} -o wide
            sudo kubectl get deployment translation-bot -n ${{ env.NAMESPACE }} -o wide
            sudo kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            sudo kubectl get secrets -n ${{ env.NAMESPACE }}
            sudo kubectl get services -n ${{ env.NAMESPACE }} -o wide
            sudo kubectl get configmaps -n ${{ env.NAMESPACE }}
            sudo kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
            sudo kubectl logs -n ${{ env.NAMESPACE }} -l app=translation-bot --tail=20 || echo "No logs available"

      - name: Cleanup deployment artifacts
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            rm -rf /tmp/k3s-deployment/
            sudo docker image prune -f

      - name: Deployment summary
        run: |
          echo "Translation Bot Deployment Complete"
          echo "Image Tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "Namespace: ${{ env.NAMESPACE }}"
          echo "Registry: ${{ env.REGISTRY_HOST }}"
          echo "Commit: ${{ github.sha }}"
          echo "Workflow: ${{ github.run_number }}"
